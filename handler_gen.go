// Code generated by genHandler. DO NOT EDIT.

package ident

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
	"github.com/lestrrat-go/bufferpool"
	"github.com/nasa9084/ident/infra"
	"github.com/nasa9084/ident/usecase"
	"github.com/nasa9084/ident/usecase/input"
	"github.com/pkg/errors"
)

func parseRequest(r *http.Request, dest input.Request) error {
	if r.Method != http.MethodGet {
		if err := json.NewDecoder(r.Body).Decode(dest); err != nil {
			return errors.Wrap(err, "parsing request body")
		}
	}
	if sessReq, ok := dest.(input.SessionRequest); ok {
		authorization := r.Header.Get("Authorization")
		if strings.Contains(authorization, ` `) {
			return errors.New("authorization header invalid")
		}
		sessReq.SetSessionID(authorization)
	}
	if arReq, ok := dest.(input.PathArgsRequest); ok {
		arReq.SetPathArgs(mux.Vars(r))
	}
	return dest.Validate()
}

const errMsg = `{"message":"%s","error":"Bad Request"}`

func renderErr(w http.ResponseWriter, err error) {
	buf := bufferpool.Get()
	defer bufferpool.Release(buf)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)
	w.Write([]byte(fmt.Sprintf(errMsg, err.Error())))
}

const (
	notfoundResponse         = `{"message":"endpoint not found","error":"Not Found"}`
	methodnotallowedResponse = `{"message":"method %s is not allowed","error":"Method Not Allowed"}`
)

func NotFoundHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusNotFound)
	w.Write([]byte(notfoundResponse))
}

func MethodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusMethodNotAllowed)
	w.Write([]byte(fmt.Sprintf(methodnotallowedResponse, r.Method)))
}

func AuthByTOTPHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.AuthByTOTPRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.AuthByTOTP(r.Context(), req, env).Render(w)
	}
}

func AuthByPasswordHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.AuthByPasswordRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.AuthByPassword(r.Context(), req, env).Render(w)
	}
}

func GetPublicKeyHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		usecase.GetPublicKey(r.Context(), env).Render(w)
	}
}

func ExistsUserHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.ExistsUserRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.ExistsUser(r.Context(), req, env).Render(w)
	}
}

func CreateUserHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.CreateUserRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.CreateUser(r.Context(), req, env).Render(w)
	}
}

func TOTPQRCodeHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.TOTPQRCodeRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.TOTPQRCode(r.Context(), req, env).Render(w)
	}
}

func VerifyTOTPHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.VerifyTOTPRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.VerifyTOTP(r.Context(), req, env).Render(w)
	}
}

func UpdateEmailHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.UpdateEmailRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.UpdateEmail(r.Context(), req, env).Render(w)
	}
}

func VerifyEmailHandler(env *infra.Environment) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req input.VerifyEmailRequest
		if err := parseRequest(r, &req); err != nil {
			renderErr(w, err)
			return
		}
		usecase.VerifyEmail(r.Context(), req, env).Render(w)
	}
}
